{
  "version": 3,
  "sources": ["../../mermaid/dist/chunks/mermaid.core/chunk-I3FGKTZ5.mjs"],
  "sourcesContent": ["import {\r\n  __name\r\n} from \"./chunk-S24QXQKS.mjs\";\r\n\r\n// src/utils/subGraphTitleMargins.ts\r\nvar getSubGraphTitleMargins = /* @__PURE__ */ __name(({\r\n  flowchart\r\n}) => {\r\n  const subGraphTitleTopMargin = flowchart?.subGraphTitleMargin?.top ?? 0;\r\n  const subGraphTitleBottomMargin = flowchart?.subGraphTitleMargin?.bottom ?? 0;\r\n  const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;\r\n  return {\r\n    subGraphTitleTopMargin,\r\n    subGraphTitleBottomMargin,\r\n    subGraphTitleTotalMargin\r\n  };\r\n}, \"getSubGraphTitleMargins\");\r\n\r\n// src/utils/lineWithOffset.ts\r\nvar markerOffsets = {\r\n  aggregation: 18,\r\n  extension: 18,\r\n  composition: 18,\r\n  dependency: 6,\r\n  lollipop: 13.5,\r\n  arrow_point: 4\r\n};\r\nfunction calculateDeltaAndAngle(point1, point2) {\r\n  if (point1 === void 0 || point2 === void 0) {\r\n    return { angle: 0, deltaX: 0, deltaY: 0 };\r\n  }\r\n  point1 = pointTransformer(point1);\r\n  point2 = pointTransformer(point2);\r\n  const [x1, y1] = [point1.x, point1.y];\r\n  const [x2, y2] = [point2.x, point2.y];\r\n  const deltaX = x2 - x1;\r\n  const deltaY = y2 - y1;\r\n  return { angle: Math.atan(deltaY / deltaX), deltaX, deltaY };\r\n}\r\n__name(calculateDeltaAndAngle, \"calculateDeltaAndAngle\");\r\nvar pointTransformer = /* @__PURE__ */ __name((data) => {\r\n  if (Array.isArray(data)) {\r\n    return { x: data[0], y: data[1] };\r\n  }\r\n  return data;\r\n}, \"pointTransformer\");\r\nvar getLineFunctionsWithOffset = /* @__PURE__ */ __name((edge) => {\r\n  return {\r\n    x: /* @__PURE__ */ __name(function(d, i, data) {\r\n      let offset = 0;\r\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\r\n        const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);\r\n        offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\r\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\r\n        const { angle, deltaX } = calculateDeltaAndAngle(\r\n          data[data.length - 1],\r\n          data[data.length - 2]\r\n        );\r\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\r\n      }\r\n      return pointTransformer(d).x + offset;\r\n    }, \"x\"),\r\n    y: /* @__PURE__ */ __name(function(d, i, data) {\r\n      let offset = 0;\r\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\r\n        const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);\r\n        offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\r\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\r\n        const { angle, deltaY } = calculateDeltaAndAngle(\r\n          data[data.length - 1],\r\n          data[data.length - 2]\r\n        );\r\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\r\n      }\r\n      return pointTransformer(d).y + offset;\r\n    }, \"y\")\r\n  };\r\n}, \"getLineFunctionsWithOffset\");\r\nif (void 0) {\r\n  const { it, expect, describe } = void 0;\r\n  describe(\"calculateDeltaAndAngle\", () => {\r\n    it(\"should calculate the angle and deltas between two points\", () => {\r\n      expect(calculateDeltaAndAngle([0, 0], [0, 1])).toStrictEqual({\r\n        angle: 1.5707963267948966,\r\n        deltaX: 0,\r\n        deltaY: 1\r\n      });\r\n      expect(calculateDeltaAndAngle([1, 0], [0, -1])).toStrictEqual({\r\n        angle: 0.7853981633974483,\r\n        deltaX: -1,\r\n        deltaY: -1\r\n      });\r\n      expect(calculateDeltaAndAngle({ x: 1, y: 0 }, [0, -1])).toStrictEqual({\r\n        angle: 0.7853981633974483,\r\n        deltaX: -1,\r\n        deltaY: -1\r\n      });\r\n      expect(calculateDeltaAndAngle({ x: 1, y: 0 }, { x: 1, y: 0 })).toStrictEqual({\r\n        angle: NaN,\r\n        deltaX: 0,\r\n        deltaY: 0\r\n      });\r\n    });\r\n    it(\"should calculate the angle and deltas if one point in undefined\", () => {\r\n      expect(calculateDeltaAndAngle(void 0, [0, 1])).toStrictEqual({\r\n        angle: 0,\r\n        deltaX: 0,\r\n        deltaY: 0\r\n      });\r\n      expect(calculateDeltaAndAngle([0, 1], void 0)).toStrictEqual({\r\n        angle: 0,\r\n        deltaX: 0,\r\n        deltaY: 0\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nexport {\r\n  getSubGraphTitleMargins,\r\n  getLineFunctionsWithOffset\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
